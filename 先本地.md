参与者与职责
UI（DishItemWidget）
加号/减号/选规格按钮与抛物线加入购物车动画
业务控制（OrderController）
对外暴露加菜、删菜、改数量的方法；连接 WebSocket；统一处理 409 强更弹窗与失败回滚
购物车控制（CartController）
本地优先更新购物车、UI 防抖（700ms 聚合多次点击）、WebSocket 发送、消息上下文（messageId→操作）记录与回滚
WebSocket 消息（WebSocketHandler）
发送加/减/删/清空等消息，接收 cart / cart_response 等事件，根据 code 路由成功/409/失败
远端（Server）
处理操作并通过 cart_response 回传 code 与 message
无规格菜品：加号按钮（默认流程）
1) 用户点击加号（DishItemWidget.onAddTap）
触发抛物线动画（存在购物车按钮坐标时）
调用 OrderController.addToCart(dish) → 委托 CartController.addToCart(dish)
2) 本地立即反馈（UI 防抖）
CartController._addToCartWithDebounce:
写入 _pendingOperations[dishKey] += 1
立即更新本地购物车 UI（不等后端）
重置 UI 防抖计时器（700ms）
3) 700ms 内无更多点击 → 刷新待处理操作
_flushPendingOperations：
若累计加 N，则调用 _sendAddDishWebSocketWithQuantity(dish, N, selectedOptions)
WebSocketHandler.sendAddDish 调用底层 _wsManager.sendAddDishToCartWithId(...)
成功后返回 messageId，CartController 保存
_operationContextMap[messageId] = {cartItem, quantity, selectedOptions}
4) 等待服务器二次确认（cart_response）
WebSocketHandler._handleCartResponseMessage 解析 code/message 与嵌套 data.message_id（originalId），分支见下
5) 成功时（code=0）
调用回调 onCartRefresh → OrderController._handleCartRefresh() → 静默拉取购物车接口，UI 与价格以服务端为准
停止操作 loading（通过 onCartUpdate）
有规格菜品：选规格弹窗（手动数量）
1) 用户点“选规格”按钮（DishItemWidget）
弹出规格与数量选择（组件代码未贴，此处为典型交互）
确认后调用 OrderController.addToCartWithQuantity(dish, quantity, selectedOptions)
→ 委托 CartController.addToCartWithQuantity(...)
2) 本地立即反馈
若已存在同款同规格：本地数量直接 +quantity；否则新增本地项
保存“最后操作上下文”（用于可能的 409）
立即调用 _sendAddDishWebSocketWithQuantity(...)（无 UI 防抖）
WebSocketHandler.sendAddDish 返回 messageId，保存到 _operationContextMap（同上）
3) 等待 cart_response 并按分支处理（同上）
服务器二次确认与异常分支（cart_response）
成功（code=0）
刷新购物车接口（onCartRefresh → _loadCartFromApi(silent:true)）
停止操作 loading（onCartUpdate）
需要强制确认（code=409）
OrderController._handleForceUpdateRequired(message, data)：
从 data.data.message_id 取出 messageId
通过 CartController.getOperationContextByMessageId(messageId) 取回“原始操作上下文”（菜品/数量/规格）
立刻弹出确认框
确认：_performForceUpdate() → 以 forceOperate=true 且 customMessageId=原messageId 重发 add
取消：_rollbackLocalState() → 清空上下文，静默刷新购物车接口以回滚本地状态
失败（code=404 或其他非 0/409）
弹出错误 Toast
onOperationFailed(originalId, message) → OrderController._handleOperationFailed(...)
若拿到 messageId：CartController.rollbackCartItem(messageId) 按保存的上下文回滚本地数量或移除新增项
拿不到 messageId：静默刷新购物车接口兜底

关键时间点/状态
UI 防抖：无规格加号点击 700ms 聚合；有规格不防抖（立即发）
操作上下文保存：以 messageId 为键保存 dish/quantity/options，用于 409 二次确认与失败回滚
成功以服务端为准：成功后总是走接口刷新，保证数量、价格、ID 等完全一致
失败兜底：拿不到 messageId 或本地上下文不匹配时，直接静默刷新购物车接口
加载状态：onCartUpdate 回调用于停止；UI 通过 OrderController.isCartOperationLoading 控制加减按钮可用性
常见入口
无规格加菜：OrderController.addToCart → CartController.addToCart（防抖）
规格+数量：OrderController.addToCartWithQuantity → CartController.addToCartWithQuantity（即时）
服务端确认：WebSocketHandler._handleCartResponseMessage
409 弹窗与强更：OrderController._handleForceUpdateRequired / _performForceUpdate
失败回滚：OrderController._handleOperationFailed → CartController.rollbackCartItem
小结
加菜分两条：无规格（700ms 聚合后发）与有规格（即时发）。
成功总是以接口刷新收口；409 走用户确认后强制重发；失败根据 messageId 精准回滚，否则刷新兜底。
通过 messageId→操作上下文 将“本地即时更新”与“服务端二次确认”安全拼合，保证体验与一致性。